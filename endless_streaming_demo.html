<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Speech Recognition Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .stop-btn {
            background: #f44336;
        }
        .stop-btn:hover {
            background: #da190b;
        }
        .status {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border-radius: 6px;
            font-weight: bold;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .transcript-container {
            margin: 20px 0;
        }
        .transcript {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            line-height: 1.5;
        }
        .interim {
            color: #666;
            font-style: italic;
        }
        .final {
            color: #000;
            margin-bottom: 5px;
        }
        .restart-info {
            color: #007bff;
            font-size: 0.9em;
            margin: 5px 0;
            padding: 5px;
            background: #e7f3ff;
            border-radius: 4px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .stat-box {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-label {
            font-size: 0.8em;
            color: #666;
            text-transform: uppercase;
        }
        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎤 Endless Speech Recognition Demo</h1>
        
        <div class="status" id="status">Ready to connect...</div>
        
        <div class="controls">
            <button id="startBtn" onclick="startRecording()">Start Endless Recording</button>
            <button id="stopBtn" onclick="stopRecording()" disabled class="stop-btn">Stop Recording</button>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Connection Status</div>
                <div class="stat-value" id="connectionStatus">Disconnected</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Stream Restarts</div>
                <div class="stat-value" id="restartCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Total Time</div>
                <div class="stat-value" id="totalTime">00:00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Audio Chunks</div>
                <div class="stat-value" id="audioChunks">0</div>
            </div>
        </div>

        <div class="transcript-container">
            <h3>Live Transcript:</h3>
            <div class="transcript" id="transcript"></div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script>
        let socket = null;
        let mediaRecorder = null;
        let isRecording = false;
        let startTime = null;
        let audioChunkCount = 0;
        let restartCount = 0;

        // Initialize socket connection
        function initSocket() {
            socket = io('/api/stt/endless', {
                transports: ['websocket', 'polling']
            });

            socket.on('connect', () => {
                updateStatus('Connected to endless streaming service', 'connected');
                updateConnectionStatus('Connected');
                console.log('Connected to endless streaming service');
            });

            socket.on('disconnect', () => {
                updateStatus('Disconnected from service', 'error');
                updateConnectionStatus('Disconnected');
                console.log('Disconnected from service');
            });

            socket.on('connected', (data) => {
                console.log('Service ready:', data);
                updateStatus('Service ready for endless streaming', 'connected');
            });

            socket.on('configured', (data) => {
                console.log('Configured:', data);
                updateStatus('Endless streaming configured and started', 'connected');
            });

            socket.on('endless_started', (data) => {
                console.log('Endless streaming started:', data);
                updateStatus('Endless streaming active', 'connected');
                startTime = Date.now();
                updateTimer();
            });

            socket.on('stream_restart', (data) => {
                console.log('Stream restart:', data);
                restartCount = data.restart_count || 0;
                updateRestartCount(restartCount);
                addRestartInfo(`Stream restart #${restartCount} at ${formatTime(Date.now() - startTime)}`);
            });

            socket.on('interim_result', (data) => {
                console.log('Interim result:', data);
                updateTranscript(data.transcript, false, data);
            });

            socket.on('final_result', (data) => {
                console.log('Final result:', data);
                updateTranscript(data.transcript, true, data);
            });

            socket.on('error', (data) => {
                console.error('Streaming error:', data);
                updateStatus(`Error: ${data.message}`, 'error');
            });

            socket.on('fatal_error', (data) => {
                console.error('Fatal error:', data);
                updateStatus(`Fatal Error: ${data.message}`, 'error');
                stopRecording();
            });

            socket.on('stopped', (data) => {
                console.log('Streaming stopped:', data);
                updateStatus('Endless streaming stopped', 'connected');
            });
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0 && socket) {
                        // Convert blob to array buffer and then to array
                        event.data.arrayBuffer().then(buffer => {
                            const audioArray = Array.from(new Uint8Array(buffer));
                            socket.emit('audio', { data: audioArray });
                            audioChunkCount++;
                            updateAudioChunks(audioChunkCount);
                        });
                    }
                };

                mediaRecorder.start(100); // Send data every 100ms
                isRecording = true;

                // Configure endless streaming
                socket.emit('config', {
                    config: {
                        encoding: 'WEBM_OPUS',
                        sampleRateHertz: 16000,
                        languageCode: 'en-US',
                        interimResults: true,
                        enableWordTimeOffsets: true,
                        enableAutomaticPunctuation: true,
                        model: 'latest_long'
                    }
                });

                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                updateStatus('Starting endless recording...', 'connected');

            } catch (error) {
                console.error('Error starting recording:', error);
                updateStatus(`Error: ${error.message}`, 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
            }

            if (socket) {
                socket.emit('stop');
            }

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateStatus('Recording stopped', 'connected');
        }

        function updateStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function updateConnectionStatus(status) {
            document.getElementById('connectionStatus').textContent = status;
        }

        function updateRestartCount(count) {
            document.getElementById('restartCount').textContent = count;
        }

        function updateAudioChunks(count) {
            document.getElementById('audioChunks').textContent = count;
        }

        function updateTimer() {
            if (startTime && isRecording) {
                const elapsed = Date.now() - startTime;
                document.getElementById('totalTime').textContent = formatTime(elapsed);
                setTimeout(updateTimer, 1000);
            }
        }

        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function updateTranscript(text, isFinal, data) {
            const transcriptEl = document.getElementById('transcript');
            
            if (isFinal) {
                // Add final result
                const finalDiv = document.createElement('div');
                finalDiv.className = 'final';
                const timestamp = data.corrected_time ? ` [${Math.floor(data.corrected_time/1000)}s]` : '';
                const confidence = data.confidence ? ` (${Math.round(data.confidence * 100)}%)` : '';
                finalDiv.innerHTML = `<strong>${text}</strong>${timestamp}${confidence}`;
                transcriptEl.appendChild(finalDiv);
                
                // Remove any interim results
                const interimEl = transcriptEl.querySelector('.interim');
                if (interimEl) {
                    interimEl.remove();
                }
            } else {
                // Update or add interim result
                let interimEl = transcriptEl.querySelector('.interim');
                if (!interimEl) {
                    interimEl = document.createElement('div');
                    interimEl.className = 'interim';
                    transcriptEl.appendChild(interimEl);
                }
                interimEl.textContent = text;
            }
            
            // Auto-scroll to bottom
            transcriptEl.scrollTop = transcriptEl.scrollHeight;
        }

        function addRestartInfo(message) {
            const transcriptEl = document.getElementById('transcript');
            const restartDiv = document.createElement('div');
            restartDiv.className = 'restart-info';
            restartDiv.textContent = `ℹ️ ${message}`;
            transcriptEl.appendChild(restartDiv);
            transcriptEl.scrollTop = transcriptEl.scrollHeight;
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            initSocket();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (isRecording) {
                stopRecording();
            }
        });
    </script>
</body>
</html>
